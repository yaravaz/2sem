% Задаем функцию и интервал
f = @(x) sin(9*(x.^2) - x);%данная функция
a = -0.7;%начальная точка отрезка
b = 0.5;%конечная точка отрезка
x_val = linspace(a, b, 100);%создается вектор x_val, 
%содержащий 100 равноотстоящих точек на интервале [a, b]
y_o = f(x_val);%вычисляются значения функции y_o в этих точках
for i = 3:9%цикл
% Выбираем равноотстоящие узлы на отрезке [-0.7, 0.5]
n = i; % Количество узлов 
n
x = linspace(a, b, n);%создает вектор x, 
%содержащий n равноотстоящих значений между a и b. 
%Этот вектор x затем используется в интерполяции для 
%определения значений функции в этих узлах.
y = f(x);
% Вычисляем интерполяционный многочлен Лагранжа для заданных узлов
x_val = linspace(a, b, 100);
%далее arrayfun для вычисления интерполированных значений 
%функции y для каждого значения xv в векторе x_val
%lagrange_interpolation(x, y, xv) вызывает функцию lagrange_interpolation 
%для каждого значения xv в векторе x_val и возвращает соответствующее 
% интерполированное значение функции y, эти значения используются для
% построения графиков
y_val = arrayfun(@(xv) lagrange_interpolation(x, y, xv), x_val);
%Таким образом, выражение p = polyfit(x, y, n-1); создает вектор p, 
%содержащий коэффициенты полинома наименьших квадратов, который 
% аппроксимирует узлы интерполяции (x, y). Этот полином затем 
% используется для построения графика с помощью функции polyval
p = polyfit(x, y, n-1);%Функция polyfit принимает векторы x и y, 
%а также степень полинома (в данном случае n-1) и возвращает 
% вектор коэффициентов полинома
y_polyfit = polyval(p, x_val);
% Сравниваем результаты
figure('Position', [0, 0, 400, 400]);%0 - координаты верхнего левого угла фигуры
%400 - ширина и высота
plot(x_val, y_val, 'b-', x_val, y_polyfit, 'r--', x, y, 'ko', x_val, y_o, 'g--');
legend({'Лагранж', 'Polyfit', 'Узлы интерполяции', 'sin(9*x^2 - x)'}, 'Location', 'best');
xlabel('x');%подпись оси абсцисс
ylabel('y');%подпись оси ординат
title(' Лагранжа и polyfit n');%заголовок графика
end



% Исходная функция и интервал
f = @(x) sin(9*(x.^2) - x);
a = -0.7;
b = 0.5;

% Количество узлов интерполяции
n = 5;

% Создание равноотстоящих узлов интерполяции
x = linspace(a, b, n);
y = f(x);

% Построение интерполяционного многочлена Ньютона
coefficients = newton_coefficients(x, y);
newton_poly = @(t) newton_evaluate(coefficients, x, t);

% Создание вектора для графика
t = linspace(a, b, 1000);

% Проверка правильности с помощью polyfit
p = polyfit(x, y, n-1);

% Отображение графиков
figure;
figure('Position', [0, 0, 400, 400]);
plot(t, newton_poly(t), 'b-', t, polyval(p, t), 'r--', x, y, 'ko', t, f(t), 'g--');
legend({'Ньютон', 'Polyfit', 'Узлы интерполяции', 'sin(9*x^2 - x)'}, 'Location', 'best');
xlabel('x');
ylabel('y');
title(' Ньютон и polyfit n');


% Исходные данные
data = [-5.00 76.70;
        -3.20 46.70;
        -1.30 19.70;
        0.87 -0.83;
        2.00 -7.20;
        2.20 -15.90;
        6.00 -22.20;
        7.00 -24.00;
        10.70 -5.80;
        10.80 2.80];

x = data(:, 1); % Входные значения x
y = data(:, 2); % Значения y

% Функция для аппроксимации
fun = @(b, x) 1 ./ (b(1) + b(2) * x + b(3) * (x.^2));

% Начальное приближение для параметров
b0_initial = 1;
b1_initial = 1;
b2_initial = 1;
initial_guess = [b0_initial, b1_initial, b2_initial];

% Метод наименьших квадратов
estimated_coeffs = lsqcurvefit(fun, initial_guess, x, y);

% Результаты аппроксимации
b0 = estimated_coeffs(1);
b1 = estimated_coeffs(2);
b2 = estimated_coeffs(3);
fprintf('Оценка коэффициентов: b0 = %.4f, b1 = %.4f, b2 = %.4f\n', b0, b1, b2);

% График аппроксимации
x_vals = linspace(min(x), max(x), 100);
y_vals = fun(estimated_coeffs, x_vals);

scatter(x, y, 'b', 'filled');
hold on;
plot(x_vals, y_vals, 'r');
xlabel('x');
ylabel('y');
legend('Исходные данные', 'Аппроксимация');
grid on;

% Исходные и предсказанные значения
disp('Исходные значения:');
disp(y_data);
disp('Предсказанные значения:');
disp(y_pred);

% Вычисление RMSE
N = length(y_data);
RMSE = sqrt(sum((y_data - y_pred).^2) / N);
RMSE

function L = lagrange_interpolation(x, y, x_val)
    n = length(x); % число узлов интерполяции
    L = 0;
    % Цикл по всем узлам интерполяции
    for i = 1:n
        P = 1; % Инициализируем переменную для базисного полинома Лагранжа
        % Цикл для вычисления базисного полинома Лагранжа
        for j = 1:n
            if i ~= j
                % Вычисляем базисный полином Лагранжа для узла i
                P = P * (x_val - x(j)) / (x(i) - x(j));
            end
        end
        % Обновляем значение многочлена Лагранжа
        L = L + y(i) * P;
    end
end



 % Функция для вычисления коэффициентов интерполяционного многочлена Ньютона
function coeffs = newton_coefficients(x, y) 
    n = length(x); % Получаем число узлов интерполяции
    coeffs = zeros(1, n);
    for k = 1:n 
        coeffs(k) = y(k); % Присваиваем текущий коэффициенту значение функции в узле
        for j = n:-1:k+1 % Цикл для вычисления разделенных разностей
            % Вычисляем разделенные разности и обновляем значения функции
            y(j) = (y(j) - y(j-1)) / (x(j) - x(j-k));
        end
    end
end

% Функция для вычисления значения интерполяционного многочлена Ньютона в заданных точках
function val = newton_evaluate(coeffs, x, t)
    n = length(coeffs);
    val = coeffs(n);
    for k = n-1:-1:1 % Цикл по коэффициентам многочлена в обратном порядке
        % Умножаем текущее значение на (t - x(k)) и добавляем текущий коэффициент
        val = val .* (t - x(k)) + coeffs(k);
    end
end